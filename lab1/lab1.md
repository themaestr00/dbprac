# Лабораторная работа №1 (теория)
## Понятие базы данных
- База данных (БД) - набор взаимосвязанных данных.

Для эффективной работы с данными нужна

- Система управления базами данных (СУБД) - комплекс программных средств для управления данными.
- СУБД отвечает за: поддержку языка БД, механизмы хранения и извлечения данных, оптимизацию процессов извлечения данных и т.д.

### Типы СУБД
- Файл-серверные: Microsoft Access.
- Клиент-серверные: MySQL, PostgreSQL, ...
- Встраиваемые: SQLite.

### Реляционные СУБД
- Теоретическая основа - реляционная алгебра
- Реляционная алгебра определяет систему операций над отношениями (таблицами): объединение, пересечение, вычитание, соединение и т.д.
- Все эти операции выражаются через SQL.

### Реляционная модель
- Сущность - например, клиенты, заказы, поставщики.
- Таблица - отношение (с математической точки зрения - подмножество декартового произведения множеств возможных значений атрибутов).
- Столбец - атрибут (пара (name, D), name - имя столбца, D - множество возможных значений).
- Строка / запись - кортеж (элемент декартового произведения множеств возможных значений атрибутов, т.е. упорядоченный набор данных фиксированной длины).
- Результирующий набор - результат SQL запроса.

### SQL
- SQL - непроцедурный язык и не язык общего назначения.
- Результатом SQL запроса является результирующий набор (как правило - таблица).
- SQL-таблица является реализацией отношения из реляционной модели и отличается от него следующими свойствами:
    1. В SQL-таблицах порядок важен, в отношениях - нет.
    2. В SQL-таблицах допускаются дубликаты строк (если нет PRIMARY KEY), отношения - множества, поэтому дубликатов в них нет.
    3. В SQL-таблицах допускаются пропуски в данных (NULL).
- DDL (Data Defenition Language) - CREATE, ALTER, DROP.
- DML (Data Manipulation Language) - SELECT, INSERT, UPDATE, DELETE.
- TCL (Transaction Control Language) - COMMIT, ROLLBACK, SAVEPOINT.
- DCL (Data Control Language) - GRANT, REVOKE, DENY.
- ANSI SQL-92 - реализуемый стандарт.
## SELECT
- Процесс или команда получения данных из базы данных называется запросом. В SQL запросы формулируются с помощью команды SELECT. В общем виде команда SELECT записывается так:

```sql
[WITH запросы_with] SELECT список_выборки FROM табличное_выражение [определение_сортировки]
```
- Выбирать можно также и выражения со столбцами.
```sql
SELECT a, b + c FROM table1;
```
### DISTINCT
- DISTINCT позволяет исключить дублирующиеся строки. Результатом выполнения данной команды будет таблица, в каждой строке которой пара значений city и country уникальна:
```sql
SELECT DISTINCT city, country
FROM employees
```
### COUNT
- COUNT — это агрегатная функция, которая возвращает количество строк (или значений) в наборе данных.
- COUNT(*) посчитает все строки в таблице, включая строки, содержащие NULL:
```sql
SELECT COUNT(*)
FROM orders
```
- COUNT(field) посчитает только те строки, для которых значение в столбце IS NOT NULL:
```sql
SELECT COUNT(country)
FROM employees
```
- COUNT (DISTINCT field) посчитает число уникальных значений в строке (NULL не считается):
```sql
SELECT COUNT(DISTINCT country)
FROM employees
```
### WHERE
- Предложение WHERE записывается так:
```sql
WHERE условие_ограничения
```
- После обработки предложения FROM каждая строка полученной виртуальной таблицы проходит проверку по условию ограничения. Если результат условия равен true, эта строка остаётся в выходной таблице, а иначе (если результат равен false или NULL) отбрасывается.
- Для комбинации условий используются логические оператор AND и OR.
- Операторы BETWEEN, IN, NOT IN упрощают написание условий. BETWEEN позволяет проверить, находится ли значение в отрезке, границы которого указываются через AND. IN и NOT IN позволяют проверить, находится ли значение в передаваемом списке.
- Что проверяют операторы IS NULL и IS NOT NULL, думаю, и так понятно)
### ORDER BY
- Результирующую таблицу можно отсортировать с помощью ORDER BY:
```sql
SELECT список_выборки
    FROM табличное_выражение
    ORDER BY выражение_сортировки1 [ASC | DESC] [NULLS { FIRST | LAST }]
             [, выражение_сортировки2 [ASC | DESC] [NULLS { FIRST | LAST }] ...]
```
- Через ASC и DESC можно указать порядок сортировки (по возрастанию и по убыванию)
- Через NULLS FIRST и NULLS LAST можно выбрать, где будут NULL значения. По умолчанию NULL значения больше любых других.
### GROUP BY
- Строки порождённой входной таблицы, прошедшие фильтр WHERE, можно сгруппировать с помощью предложения GROUP BY:
```sql
SELECT список_выборки
    FROM ...
    [WHERE ...]
    GROUP BY группирующий_столбец [, группирующий_столбец]...
```
- Предложение GROUP BY группирует строки таблицы, объединяя их в одну группу при совпадении значений во всех перечисленных столбцах. Порядок, в котором указаны столбцы, не имеет значения. В результате наборы строк с одинаковыми значениями преобразуются в отдельные строки, представляющие все строки группы.
- Вообще говоря, в группированной таблице столбцы, не включённые в список GROUP BY, можно использовать только в агрегатных выражениях.
### HAVING
- Если таблица была сгруппирована с помощью GROUP BY, но интерес представляют только некоторые группы, отфильтровать их можно с помощью предложения HAVING, действующего подобно WHERE. Записывается это так:
```sql
SELECT список_выборки FROM ... [WHERE ...] GROUP BY ... HAVING логическое_выражение
```
## Теоретико-множественные операции
- Результаты двух запросов можно обработать, используя операции над множествами: объединение, пересечение и вычитание. Эти операции записываются соответственно так:
```sql
запрос1 UNION [ALL] запрос2
запрос1 INTERSECT [ALL] запрос2
запрос1 EXCEPT [ALL] запрос2
```
### UNION
- UNION по сути добавляет результаты второго запроса к результатам первого (хотя никакой порядок возвращаемых строк при этом не гарантируется). Более того, эта операция убирает дублирующиеся строки из результата так же, как это делает DISTINCT, если только не указано UNION ALL.
### INTERSECT
- INTERSECT возвращает все строки, содержащиеся в результате и первого, и второго запроса. Дублирующиеся строки отфильтровываются, если не указано ALL.
### EXCEPT
- EXCEPT возвращает все строки, которые есть в результате первого запроса, но отсутствуют в результате второго. (Иногда это называют разницей двух запросов.) И здесь дублирующиеся строки отфильтровываются, если не указано ALL.
- При добавлении ALL к EXCEPT результирующие строки первого запроса, встречающиеся чаще, чем во втором, отсекаться не будут.
## JOIN
- Запросы, обращающиеся к разным таблицам (или нескольким экземплярам одной таблицы), называются соединениями (JOIN). Такие запросы содержат выражение, указывающее, какие строки одной таблицы нужно объединить со строками другой таблицы.
Cуществуют различные виды JOINов: INNER JOIN (JOIN), LEFT/RIGHT OUTER JOIN, FULL JOIN, CROSS JOIN, SELF JOIN.
### INNER JOIN или просто JOIN
- Соединяет только те строки левой таблицы, для которых есть соответствующие строки правой таблицы:
```sql
таблица1 JOIN таблица2 ON связь
```
### LEFT/RIGHT OUTER JOIN или LEFT/RIGHT JOIN
- Как INNER JOIN, но включает также и те строки, левой/правой таблицы, для которых соответствующей строки в другой таблице нет.
### FULL JOIN
- FULL JOIN объединяет таблицы, полученные при LEFT и RIGHT JOIN.
### CROSS JOIN
- CROSS JOIN или все со всеми. Вовзращает декартовое произведение строк участвующих в CROSS JOIN таблиц.
### SELF JOIN
- Синтаксически не отличается от описанных выше, но применяется для строк одной и той же таблицы.
### USING
- Для соединения по столбцам с одинаковыми именами можно использовать USING для сокращения кода:
```sql
Вместо ON orders.order_id = order_details.order_id 
Можно использовать USING(order_id)
``` 
## Функции
### Агрегатные функции
- Агрегатная функция в SQL – это функция, которая выполняет вычисление над набором значений (например, из одного или нескольких столбцов) и возвращает одно сводное значение. 
- Основные агрегатные функции включают SUM() (сумма), AVG() (среднее арифметическое), COUNT() (количество), MAX() (максимум) и MIN() (минимум). Эти функции часто используются для анализа данных, построения отчетов и выполнения групповой обработки с помощью предложения GROUP BY. 
- Агрегатные функции преимущественно игнорируют NULL и не включают его в суммы, подсчет (кроме COUNT(*)) и прочие групповые операции.
### Оконные функции
- Окно — это некоторое выражение, описывающее набор строк, которые будет обрабатывать функция и порядок этой обработки. Порядок обработки можно менять, например, через ORDER BY. Окно может быть просто задано пустыми скобками (), т.е. окном являются все строки результата запроса. 
- Синтаксис оконных функций таков:
```sql
функция OVER окно
```
- В оконное выражение можно добавить слово PARTITION BY [expression]. Тогда подсчет будет идти в каждой группе отдельно
- Примеры оконных функций: row_number(), rank(), dense_rank(), lead().
- Можно использовать и агрегатные функции. Они агрегируют значения для всех строк в PARTITION, но при добавлении порядка через ORDER BY поведение меняется, функция начинает агрегировать значения до текущей обрабатываемой строки. Например: SUM считает n-ю частичную сумму по переданному столбцу.
## Оператор WITH и рекурсивные запросы
- WITH предоставляет способ записывать дополнительные операторы для применения в больших запросах. Эти операторы, которые также называют общими табличными выражениями (Common Table Expressions, CTE), можно представить как определения временных таблиц, существующих только для одного запроса.
- Запрос в WITH RECURSIVE может обращаться к своему собственному результату. Рекурсивный запрос вычисляется итеративно. Сначала вычисляется нерекурсивная часть до UNION (UNION ALL) результат нерекурсивной части - рабочая таблица. Далее пока рабочая таблица не пуста запрос может обращаться к рабочей таблице. Результат запроса помещается в промежуточную таблицу, которая потом заменит собой рабочую.
Пример рекурсивного запроса:
```sql
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t;
```